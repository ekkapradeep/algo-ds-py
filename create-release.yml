trigger:
  branches:
    include:
      - main

variables:
  fixVersion: '1.0.0'

stages:
  - stage: ReleaseBranch
    displayName: "Create/Update Release Branch"
    jobs:
      - job: CreateReleaseBranch
        displayName: "Create or Update Release Branch for FixVersion"
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            persistCredentials: true

          - task: PowerShell@2
            displayName: "Discover Azure DevOps Settings"
            inputs:
              targetType: 'inline'
              pwsh: true
              script: |
                Write-Host "##[section]üîç Discovering Azure DevOps Environment..."
                
                # Get built-in environment variables
                $collectionUri = "$(System.CollectionUri)"
                $teamProject = "$(System.TeamProject)"
                $teamProjectId = "$(System.TeamProjectId)"
                $repoName = "$(Build.Repository.Name)"
                
                Write-Host "Collection URI: $collectionUri"
                Write-Host "Team Project: $teamProject"
                Write-Host "Team Project ID: $teamProjectId"
                Write-Host "Repository Name: $repoName"
                
                # Test different URL formats
                $orgUrl = $collectionUri
                $project = $teamProject
                $repo = $repoName
                
                $token = "$(System.AccessToken)"
                $headers = @{ 
                    Authorization = "Bearer $token"
                    "Content-Type" = "application/json"
                }
                
                Write-Host "##[section]Testing connection with discovered values..."
                Write-Host "Organization URL: $orgUrl"
                Write-Host "Project: $project"
                Write-Host "Repository: $repo"
                
                # Test connection to Projects API
                try {
                    $projectsUrl = "$orgUrl/_apis/projects?api-version=7.0"
                    Write-Host "Testing URL: $projectsUrl"
                    $projects = Invoke-RestMethod -Uri $projectsUrl -Method Get -Headers $headers
                    Write-Host "‚úÖ Successfully connected to organization!"
                    Write-Host "Available projects:"
                    foreach ($proj in $projects.value) {
                        Write-Host "  - $($proj.name) (ID: $($proj.id))"
                        if ($proj.name -eq $project) {
                            Write-Host "    ‚úÖ This is our project!"
                        }
                    }
                } catch {
                    Write-Host "##[error]‚ùå Failed to list projects: $($_.Exception.Message)"
                    Write-Host "This might be a permission issue or incorrect URL."
                }
                
                # Test specific project access
                try {
                    $projectUrl = "$orgUrl/$project/_apis/projects/$project?api-version=7.0"
                    Write-Host "Testing project URL: $projectUrl"
                    $projectInfo = Invoke-RestMethod -Uri $projectUrl -Method Get -Headers $headers
                    Write-Host "‚úÖ Successfully accessed project: $($projectInfo.name)"
                } catch {
                    Write-Host "##[error]‚ùå Failed to access project '$project': $($_.Exception.Message)"
                    Write-Host "The project might not exist or you don't have access."
                }
                
                # Set variables for next steps
                Write-Host "##vso[task.setvariable variable=DiscoveredOrgUrl]$orgUrl"
                Write-Host "##vso[task.setvariable variable=DiscoveredProject]$project"
                Write-Host "##vso[task.setvariable variable=DiscoveredRepo]$repo"

          - task: PowerShell@2
            displayName: "Create/Update Release Branch"
            inputs:
              targetType: 'inline'
              pwsh: true
              script: |
                $fixVersion = "${{ variables.fixVersion }}"
                Write-Host "üöÄ Starting release branch update for FixVersion: ${fixVersion}"
                
                # Use discovered values
                $orgUrl = "$(DiscoveredOrgUrl)"
                $project = "$(DiscoveredProject)"
                $repo = "$(DiscoveredRepo)"
                $releaseBranch = "release/${fixVersion}"
                $token = "$(System.AccessToken)"
                $headers = @{ 
                    Authorization = "Bearer $token"
                    "Content-Type" = "application/json"
                }
                
                Write-Host "Using configuration:"
                Write-Host "  Organization: $orgUrl"
                Write-Host "  Project: $project"
                Write-Host "  Repository: $repo"
                Write-Host "  Release Branch: $releaseBranch"
                
                # --- STEP 1: Fetch work items ---
                Write-Host "##[section]üîç Fetching work items with FixVersion = ${fixVersion}..."
                
                # First, let's check what work item fields are available
                try {
                    $fieldsUrl = "$orgUrl/$project/_apis/wit/fields?api-version=7.0"
                    $fields = Invoke-RestMethod -Uri $fieldsUrl -Headers $headers
                    Write-Host "Available custom fields:"
                    $customFields = $fields.value | Where-Object { $_.referenceName -like "Custom.*" }
                    foreach ($field in $customFields) {
                        Write-Host "  - $($field.referenceName): $($field.name)"
                    }
                } catch {
                    Write-Host "‚ö†Ô∏è Could not fetch fields: $($_.Exception.Message)"
                }
                
                # Try different possible field names for FixVersion
                $possibleFields = @("Custom.FixVersion", "Microsoft.VSTS.Common.FixVersion", "Custom.ReleaseVersion")
                
                foreach ($fieldName in $possibleFields) {
                    Write-Host "Trying field: $fieldName"
                    $wiql = @{
                        query = "SELECT [System.Id] FROM WorkItems WHERE [System.TeamProject] = '$project' AND [$fieldName] = '$fixVersion'"
                    } | ConvertTo-Json
                    
                    $wiqlUrl = "$orgUrl/$project/_apis/wit/wiql?api-version=7.0"
                    
                    try {
                        $wiqlResult = Invoke-RestMethod -Uri $wiqlUrl -Method Post -Headers $headers -Body $wiql -ContentType "application/json"
                        
                        if ($wiqlResult.workItems -and $wiqlResult.workItems.Count -gt 0) {
                            Write-Host "‚úÖ Found $($wiqlResult.workItems.Count) work items using field: $fieldName"
                            break
                        } else {
                            Write-Host "‚ö†Ô∏è No work items found with field: $fieldName"
                        }
                    } catch {
                        Write-Host "‚ùå Field '$fieldName' not found or not accessible"
                    }
                }
                
                if (-not $wiqlResult.workItems -or $wiqlResult.workItems.Count -eq 0) {
                    Write-Host "##[warning]No work items found for FixVersion '$fixVersion' with any known field."
                    Write-Host "Please check:"
                    Write-Host "1. The FixVersion field exists in your project"
                    Write-Host "2. Work items are tagged with FixVersion = '$fixVersion'"
                    Write-Host "3. The field name matches one of: $($possibleFields -join ', ')"
                    exit 0
                }
                
                # --- STEP 2: Process work items ---
                $finalWorkItems = @()
                
                foreach ($wi in $wiqlResult.workItems) {
                    $wiId = $wi.id
                    Write-Host "Processing Work Item #${wiId}..."
                    
                    $relationsUrl = "$orgUrl/$project/_apis/wit/workitems/$wiId?`$expand=relations&api-version=7.0"
                    
                    try {
                        $wiDetails = Invoke-RestMethod -Uri $relationsUrl -Headers $headers
                        Write-Host "‚úÖ Work Item #${wiId}: $($wiDetails.fields.'System.Title')"
                        
                        $prLinks = $wiDetails.relations | Where-Object { $_.rel -eq "ArtifactLink" -and $_.url -like "*PullRequest*" }
                        
                        if (-not $prLinks) {
                            Write-Host "‚ö†Ô∏è Work Item #${wiId} has no linked PRs. Skipping..."
                            continue
                        }
                        
                        Write-Host "Found $($prLinks.Count) linked PR(s)"
                        $allApproved = $true
                        
                        foreach ($prLink in $prLinks) {
                            if ($prLink.url -match "vstfs:///Git/PullRequestId/(\d+)") {
                                $prId = $matches[1]
                                $prApiUrl = "$orgUrl/$project/_apis/git/repositories/$repo/pullRequests/$prId?api-version=7.0"
                                
                                try {
                                    $pr = Invoke-RestMethod -Uri $prApiUrl -Headers $headers
                                    
                                    if ($pr.status -ne "completed" -or $pr.mergeStatus -ne "succeeded") {
                                        Write-Host "‚ùå PR #${prId} is not merged (Status: $($pr.status), Merge: $($pr.mergeStatus))"
                                        $allApproved = $false
                                        break
                                    } else {
                                        Write-Host "‚úÖ PR #${prId} is merged successfully"
                                    }
                                } catch {
                                    Write-Host "‚ùå Failed to fetch PR #${prId}: $($_.Exception.Message)"
                                    $allApproved = $false
                                    break
                                }
                            }
                        }
                        
                        if ($allApproved) {
                            Write-Host "‚úÖ Work Item #${wiId} approved for release"
                            $finalWorkItems += $wiId
                        }
                        
                    } catch {
                        Write-Host "##[error]‚ùå Failed to process Work Item #${wiId}: $($_.Exception.Message)"
                    }
                }
                
                if (-not $finalWorkItems) {
                    Write-Host "##[warning]No work items qualify for release."
                    exit 0
                }
                
                # --- STEP 3: Create/Update release branch ---
                Write-Host "##[section]üîß Preparing release branch: ${releaseBranch}"
                
                # Configure git
                git config --global user.email "build@azure.dev"
                git config --global user.name "Azure DevOps"
                
                git fetch origin
                $branchExists = git ls-remote --heads origin $releaseBranch
                
                if ($branchExists) {
                    Write-Host "üì¶ Release branch exists. Updating..."
                    git checkout $releaseBranch
                    git pull origin $releaseBranch
                } else {
                    Write-Host "üå± Creating new release branch from main..."
                    git checkout main
                    git pull origin main
                    git checkout -b $releaseBranch
                }
                
                # --- STEP 4: Merge approved changes ---
                foreach ($wiId in $finalWorkItems) {
                    Write-Host "Merging changes for Work Item #${wiId}..."
                    # This would merge the associated PR branches
                    # Implementation depends on your specific branch strategy
                }
                
                git push origin $releaseBranch
                Write-Host "##[section]üéâ Release branch ${releaseBranch} updated successfully!"